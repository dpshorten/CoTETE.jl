<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public Interface · CoTETE.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CoTETE.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background</a></li><li><a class="tocitem" href="../quickStart/">Quick Start</a></li><li class="is-active"><a class="tocitem" href>Public Interface</a></li><li><a class="tocitem" href="../internals/">Internal</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dpshorten/CoTETE.jl/blob/master/docs/src/public.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Interface-1"><a class="docs-heading-anchor" href="#Public-Interface-1">Public Interface</a><a class="docs-heading-anchor-permalink" href="#Public-Interface-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CoTETE.estimate_TE_from_event_times" href="#CoTETE.estimate_TE_from_event_times"><code>CoTETE.estimate_TE_from_event_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">estimate_TE_from_event_times(
  parameters::CoTETEParameters,
  target_events::Array{&lt;:AbstractFloat},
  source_events::Array{&lt;:AbstractFloat};
  conditioning_events::Array{&lt;:AbstractFloat} = Float32[],
)</code></pre><p>Estimate the TE from lists of raw event times.</p><div class="admonition is-info"><header class="admonition-header">Single conditioning process</header><div class="admonition-body"><p>Note that although the framework developed in <a href="https://doi.org/10.1101/2020.06.16.154377">our paper</a>   considers an arbitrary number of extra   conditioning processes, at present the framework can only handle a single such process.   This will change in future releases.</p></div></div><p><strong>Examples</strong></p><p>This example demonstrates estimating the TE between uncoupled homogeneous Poisson processes. This is covered in section II A of <a href="https://doi.org/10.1101/2020.06.16.154377">our paper</a>. We first create the source and target processes, each with 10 000 events and with rate 1, before running the estimator.</p><pre><code class="language-julia-repl">julia&gt; source = sort(1e4*rand(Int(1e4)));

julia&gt; target = sort(1e4*rand(Int(1e4)));

julia&gt; parameters = CoTETE.CoTETEParameters(l_x = 1, l_y = 1);

julia&gt; TE = CoTETE.estimate_TE_from_event_times(parameters, target, source)
0.0

julia&gt; abs(TE - 0) &lt; 0.05 # For Doctesting purposes
true
</code></pre><p>We can also try increasing the length of the target and source history embeddings</p><pre><code class="language-julia-repl">julia&gt; parameters = CoTETE.CoTETEParameters(l_x = 3, l_y = 3);

julia&gt; TE = CoTETE.estimate_TE_from_event_times(parameters, target, source)
0.0

julia&gt; abs(TE - 0) &lt; 0.1 # For Doctesting purposes
true
</code></pre><p>Let&#39;s try some other options</p><pre><code class="language-julia-repl">julia&gt; using Distances: Cityblock

julia&gt; parameters = CoTETE.CoTETEParameters(l_x = 1,
                                            l_y = 2,
                                            k_global = 3,
                                            auto_find_start_and_num_events = false,
                                            start_event = 100,
                                            num_target_events = 5000,
                                            num_samples_ratio = 2.3,
                                            metric = Cityblock());

julia&gt; TE = CoTETE.estimate_TE_from_event_times(parameters, target, source)
0.0

julia&gt; abs(TE - 0) &lt; 0.1 # For Doctesting purposes
true</code></pre><p>The next example applies the estimator to a more complex problem, specifically, the process described as example B in <a href="https://doi.org/10.1103/PhysRevE.95.032319">Spinney et. al.</a>. The application of the estimator to this example is covered in section II B of <a href="https://doi.org/10.1101/2020.06.16.154377">our paper</a>. We create the source process as before. Howevever, the target process is originally created as an homogeneous Poisson process with rate 10, before a thinning algorithm is applied to it, in order to provide the dependence on the source.</p><pre><code class="language-julia">julia&gt; source = sort(1e4*rand(Int(1e4)));

julia&gt; target = sort(1e4*rand(Int(1e5)));

julia&gt; function thin_target(source, target, target_rate)
           # Remove target events occurring before first source
    	   start_index = 1
    	   while target[start_index] &lt; source[1]
           	 start_index += 1
    	   end
    	   target = target[start_index:end]

	   new_target = Float64[]
    	   index_of_last_source = 1
    	   for event in target
               while index_of_last_source &lt; length(source) &amp;&amp; source[index_of_last_source + 1] &lt; event
               	     index_of_last_source += 1
               end
               distance_to_last_source = event - source[index_of_last_source]
               λ = 0.5 + 5exp(-50(distance_to_last_source - 0.5)^2) - 5exp(-50(-0.5)^2)
               if rand() &lt; λ/target_rate
               	  push!(new_target, event)
               end
           end
    	   return new_target
       end

julia&gt; target = thin_target(source, target, 10);

julia&gt; parameters = CoTETE.CoTETEParameters(l_x = 1, l_y = 1);

julia&gt; TE = CoTETE.estimate_TE_from_event_times(parameters, target, source)
0.5076

julia&gt; abs(TE - 0.5076) &lt; 0.05 # For Doctesting purposes
true</code></pre><p>We can also try extending the length of the target embeddings in order to better resolve this dependency</p><pre><code class="language-julia">julia&gt; parameters = CoTETE.CoTETEParameters(l_x = 3, l_y = 1);

julia&gt; TE = CoTETE.estimate_TE_from_event_times(target, source, 3, 1)
0.5076

julia&gt; abs(TE - 0.5076) &lt; 0.05 # For Doctesting purposes
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dpshorten/CoTETE.jl/blob/8e335f37243c7207d01c2330856deab07fb9baf4/src/CoTETE.jl#L92-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoTETE.estimate_TE_and_p_value_from_event_times" href="#CoTETE.estimate_TE_and_p_value_from_event_times"><code>CoTETE.estimate_TE_and_p_value_from_event_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function estimate_TE_and_p_value_from_event_times(
    parameters::CoTETEParameters,
    target_events::Array{&lt;:AbstractFloat},
    source_events::Array{&lt;:AbstractFloat};
    conditioning_events::Array{&lt;:AbstractFloat} = Float32[],
    return_surrogate_TE_values::Bool = false,
)</code></pre><p>calculate the TE and the <span>$p$</span> value of it being statistically different from zero.</p><p>This example demonstrates estimating the TE and <span>$p$</span> value between uncoupled homogeneous Poisson processes. As the true value of the TE is zero, we expect the <span>$p$</span> value to be uniformly disributed between zero and one.</p><p>We first create the source and target processes, each with 1 000 events and with rate 1, before running the estimator and the surrogate generation procedure.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; source = sort(1e3*rand(Int(1e3)));

julia&gt; target = sort(1e3*rand(Int(1e3)));

julia&gt; parameters = CoTETE.CoTETEParameters(l_x = 1, l_y = 1);

julia&gt; TE, p = CoTETE.estimate_TE_and_p_value_from_event_times(parameters, target, source)
(0.0, 0.5)

julia&gt; p &gt; 0.05 # For Doctesting purposes. Should fail every now and then.
true
</code></pre><p>This second example shows using this method on coupled processes for which the true value of the TE is nonzero. As there is a strong coupling between the source and target, we expect the <span>$p$</span> value to be close to 0. The application of the estimator to this example is covered in section II B of <a href="https://doi.org/10.1101/2020.06.16.154377">our paper</a>. See the above examples for <code>estimate_TE_from_event_times</code> for more details as well as the implementation of the thinning algorithm.</p><p>We create the source process as before. Howevever, the target process is originally created as an homogeneous Poisson process with rate 10, before the thinning algorithm is applied to it, in order to provide the dependence on the source.</p><pre><code class="language-julia">julia&gt; source = sort(1e3*rand(Int(1e3)));

julia&gt; target = sort(1e3*rand(Int(1e4)));

julia&gt; target = thin_target(source, target, 10);

julia&gt; parameters = CoTETE.CoTETEParameters(l_x = 1, l_y = 1);

julia&gt; TE, p = CoTETE.estimate_TE_and_p_value_from_event_times(parameters, target, source)
(0.5, 0.01)

julia&gt; p &lt; 0.05 # For Doctesting purposes. Should fail very rarely.
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dpshorten/CoTETE.jl/blob/8e335f37243c7207d01c2330856deab07fb9baf4/src/CoTETE.jl#L240-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoTETE.estimate_AIS_from_event_times" href="#CoTETE.estimate_AIS_from_event_times"><code>CoTETE.estimate_AIS_from_event_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">estimate_AIS_from_event_times(
  parameters::CoTETEParameters,
  target_events::Array{&lt;:AbstractFloat},
  source_events::Array{&lt;:AbstractFloat};
  conditioning_events::Array{&lt;:AbstractFloat} = Float32[],
)</code></pre><p>Estimate the Active Information Storage (AIS) from lists of raw event times.</p><p>See <a href="https://doi.org/10.1007/978-3-642-32952-4">this thesis</a> for a description of AIS.</p><p><strong>Examples</strong></p><p>This example estimates the AIS on an homogeneous Poisson process. The true value of the AIS on such a process is zero.</p><pre><code class="language-julia-repl">julia&gt; target = sort(1e4*rand(Int(1e4)));

julia&gt; parameters = CoTETE.CoTETEParameters(l_x = 1);

julia&gt; AIS = CoTETE.estimate_AIS_from_event_times(parameters, target)
0.0

julia&gt; abs(AIS - 0) &lt; 0.05 # For Doctesting purposes
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dpshorten/CoTETE.jl/blob/8e335f37243c7207d01c2330856deab07fb9baf4/src/CoTETE.jl#L349-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoTETE.estimate_AIS_and_p_value_from_event_times" href="#CoTETE.estimate_AIS_and_p_value_from_event_times"><code>CoTETE.estimate_AIS_and_p_value_from_event_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">estimate_AIS_and_p_value_from_event_times(
  parameters::CoTETEParameters,
  target_events::Array{&lt;:AbstractFloat},
  source_events::Array{&lt;:AbstractFloat};
  conditioning_events::Array{&lt;:AbstractFloat} = Float32[],
)</code></pre><p>Estimate the Active Information Storage (AIS) along with the <span>$p$</span> value of the AIS being different from 0 from lists of raw event times.</p><p>See <a href="https://doi.org/10.1007/978-3-642-32952-4">this thesis</a> for a description of AIS.</p><p><strong>Examples</strong></p><p>This example estimates the AIS and <span>$p$</span> value on an homogeneous Poisson process. The true value of the AIS on such a process is zero. We expect the <span>$p$</span> value to be uniformly distributed between zero and 1.</p><pre><code class="language-julia-repl">julia&gt; target = sort(1e3*rand(Int(1e3)));

julia&gt; parameters = CoTETE.CoTETEParameters(l_x = 1);

julia&gt; AIS, p = CoTETE.estimate_AIS_and_p_value_from_event_times(parameters, target)
(0.0, 0.5)

julia&gt; p &gt; 0.05 # For Doctesting purposes. Should fail from time to time
true
</code></pre><p>This next example estimates the AIS for a process where we know that the AIS must be nonzero. This process has an event occurring every one time unit, with a bit of noise added to the event times.</p><pre><code class="language-julia-repl">julia&gt; target = sort(cumsum(ones(Int(1e3))) .+ 1e-2*randn(Int(1e3)));

julia&gt; parameters = CoTETE.CoTETEParameters(l_x = 1);

julia&gt; AIS, p = CoTETE.estimate_AIS_and_p_value_from_event_times(parameters, target)
(1.0, 0.01)

julia&gt; p &lt; 0.05 # For Doctesting purposes. Should fail from time to time
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dpshorten/CoTETE.jl/blob/8e335f37243c7207d01c2330856deab07fb9baf4/src/CoTETE.jl#L392-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoTETE.CoTETEParameters" href="#CoTETE.CoTETEParameters"><code>CoTETE.CoTETEParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CoTETEParameters
    l_x::Integer = 0
    l_y::Integer = 0
    l_z::Integer = 0
    auto_find_start_and_num_events::Bool = true
    num_target_events_cap::Integer = -1
    start_event::Integer = 1
    num_target_events::Integer = 0
    num_samples_ratio::AbstractFloat = 1.0
    k_global::Integer = 5
    metric::Metric = Euclidean()
    kraskov_noise_level::AbstractFloat = 1e-8
    num_surrogates::Integer = 100
    surrogate_num_samples_ratio::AbstractFloat = 1.0
    k_perm::Integer = 5
end</code></pre><ul><li><code>l_x::Integer</code>: The number of intervals in the target process to use in the history embeddings. Corresponds to <span>$l_X$</span> in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</li><li><code>l_y::Integer</code>: The number of intervals in the source process to use in the history embeddings. Corresponds to <span>$l_Y$</span> in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</li><li><code>l_z::Integer = 0</code>: The number of intervals in the single conditioning process to use in the history embeddings. Corresponds to <span>$l_{Z_1}$</span> in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.<div class="admonition is-info"><header class="admonition-header">Single conditioning process</header><div class="admonition-body"><p>Note that although the framework developed in <a href="https://doi.org/10.1101/2020.06.16.154377">our paper</a> considers an arbitrary number of extra conditioning processes, at present the framework can only handle a single such process. This will change in future releases.</p></div></div></li><li><code>auto_find_start_and_num_events::Bool = true</code>: When set to true, the start event will be set to the first event for which there are sufficient preceding events in all processes such that the embeddings can be constructed. The number of target events will be set such that all time between this first event and the last target event is included.</li><li><code>num_target_events_cap::Integer = -1</code></li><li><code>start_event::Integer = 1</code>: only used when <code>auto_find_start_and_num_events = false</code>. The index of the event in the target process from which to start the analysis.</li><li><code>num_target_events::Integer = 0</code>: only used when <code>auto_find_start_and_num_events = false</code>. The TE will be calculated on the time series from the timestamp of the <code>start_event</code>-th event of the target process to the timestamp of the <code>start_event + num_target_events</code>-th event of the target process.</li><li><code>num_samples_ratio::AbstractFloat = 1.0</code>: Controls the number of samples used to estimate the probability density of histories unconditional of the occurrence of events in the target process. This number of samples will be <code>num_samples_ratio * num_target_events</code>. Corresponds to <span>$N_U/N_X$</span> in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</li><li><code>k_global::Integer = 5</code>: The number of nearest neighbours to consider in initial searches.</li><li><code>metric::Metric = Euclidean()</code>: The metric to use for nearest neighbour and radius searches.</li><li><code>num_surrogates::Integer = 100</code>:</li><li><code>surrogate_num_samples_ratio::AbstractFloat = 1.0</code>: Controls the number of samples used to to construct the alternate set of history embeddings used by our local permutation scheme. This number of samples will be <code>surrogate_num_samples_ratio * num_target_events</code>. Corresponds to <span>$N_{U, \textrm{surrogate}}/N_X$</span> in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</li><li><code>k_perm::Integer = 5</code>: The number of neighbouring source embeddings from which to randomly select a replacement embedding in the local permutation scheme.</li></ul><p><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> Shorten, D. P., Spinney, R. E., Lizier, J.T. (2020). <a href="https://doi.org/10.1101/2020.06.16.154377">Estimating Transfer Entropy in Continuous Time Between Neural Spike Trains or Other Event-Based Data</a>. bioRxiv 2020.06.16.154377.</p><p><sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> Spinney, R. E., Prokopenko, M., &amp; Lizier, J. T. (2017). <a href="https://doi.org/10.1103/PhysRevE.95.032319">Transfer entropy in continuous time, with applications to jump and neural spiking processes</a>. Physical Review E, 95(3), 032319.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L62">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickStart/">« Quick Start</a><a class="docs-footer-nextpage" href="../internals/">Internal »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 15 July 2020 16:46">Wednesday 15 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
