<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Background · CoTETE.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CoTETE.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Background</a><ul class="internal"><li><a class="tocitem" href="#References-1"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../quickStart/">Quick Start</a></li><li><a class="tocitem" href="../public/">Public Interface</a></li><li><a class="tocitem" href="../internals/">Internal Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Background</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Background</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dpshorten/CoTETE.jl/blob/master/docs/src/background.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Background-1"><a class="docs-heading-anchor" href="#Background-1">Background</a><a class="docs-heading-anchor-permalink" href="#Background-1" title="Permalink"></a></h1><p>Transfer entropy is a measure of information flow between a source and a target time series <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup><sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. In the context of event-based data, it measures how much the knowledge of the times of historic events in the source decreases our uncertainty about the occurrence of events in the target. Getting a clearer picture of what TE is measuring is easiest done, initially at least, in discrete time.</p><p><img src="../intro_discrete.png" alt="Discrete TE"/></p><p>The above diagram shows the raw membrane potentials of two neurons from which spikes are extracted. Time is then discretised into bins of width <span>$\Delta t$</span> to give us two binary time series (labelled <span>$X$</span> and <span>$Y$</span> for the source and target, respectively). The binary values these processes take on signify the presence of an event (spike) in each bin. For each such value <span>$x_t$</span> in the target process, we can ask what the probability of that value is given the history of the target process <span>$p(x_t \, | \, \mathbf{x}_{&lt;t})$</span>. In practice, such conditional probabilities can only be estimated for histories of limited length. As such, we use a history embedding of <span>$m$</span> bins. This embedding is usually chosen to be the <span>$m$</span> bins preceding the <span>$t$</span>-th bin under consideration. In the above diagram, <span>$m$</span> is chosen to be 4, and so we are estimating <span>$p(x_t \, | \, \mathbf{x}_{t-4:t-1})$</span>. So, for the specific example <span>$x_t$</span> pulled out of the diagram, we are asking what the probability of the bin having a value of <span>$0$</span> is (that is, the probability of there being no spike in the bin), given that the preceding <span>$4$</span> bins were <span>$\{0, 1, 0, 0\}$</span>.</p><p>We can also ask what the probability of <span>$x_t$</span> is given history embeddings of both the source and the target: <span>$p(x_t \, | \, \mathbf{x}_{t-4:t-1}, \mathbf{y}_{t-4:t-1})$</span>. Looking at our specific pulled-out example again, we would be asking for the probability of the target bin having a value of <span>$0$</span> given that the preceding <span>$4$</span> bins of the target were <span>$\{0, 1, 0, 0\}$</span> and the preceding <span>$4$</span> bins of the source were <span>$\{0, 1, 0, 1\}$</span>.</p><p>We can then compare the probabilities <span>$p(x_t \, | \, \mathbf{x}_{t-4:t-1}, \mathbf{y}_{t-4:t-1})$</span> and <span>$p(x_t \, | \, \mathbf{x}_{t-4:t-1})$</span> to determine whether the knowledge of the source reduced our uncertainty about the next state of the target. If <span>$p(x_t \, | \, \mathbf{x}_{t-4:t-1}, \mathbf{y}_{t-4:t-1}) &gt; p(x_t \, | \, \mathbf{x}_{t-4:t-1})$</span> then the source allowed us to better predict the next state of the target and so reduced our uncertainty. Conversely, if <span>$p(x_t \, | \, \mathbf{x}_{t-4:t-1}, \mathbf{y}_{t-4:t-1}) &lt; p(x_t \, | \, \mathbf{x}_{t-4:t-1})$</span> then the source was misinformative <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.</p><p>One way of turning these two probabilities into a measurement of &quot;informativeness&quot; is to take the log of their ratio. We shall label this <span>$\mathbf{t}_{Y \to X}$</span>.</p><div>\[ \mathbf{t}_{Y \to X} = \ln\frac{p(x_t \, | \, \mathbf{x}_{&lt;t}, \mathbf{y}_{&lt;t})}{p(x_t \, | \, \mathbf{x}_{&lt;t})}\]</div><p>We use <span>$\mathbf{t}_{Y \to X}^{l, m}$</span> for the same quantity calculated for specific source and target history embedding lengths.</p><div>\[ \mathbf{t}_{Y \to X}^{l, m} = \ln\frac{p(x_t \, | \, \mathbf{x}_{t-m:t-1}, \mathbf{y}_{t-l:t-1})}{p(x_t \, | \, \mathbf{x}_{t-m:t-1})}\]</div><p><span>$\mathbf{t}_{Y \to X}$</span> will be positive in cases where the source is informative and negative when it is misinformative. However, it is only a measure of how informative the source was in <em>that specific time bin</em>. In many cases, such as network inference, we are interested in how generally informative one time series is of another. As such we take the average of <span>$\mathbf{t}_{Y \to X}$</span> and label it <span>$\mathbf{T}_{Y \to X}$</span>.</p><div>\[\mathbf{T}_{Y \to X} = \frac{1}{N}\sum_{t=1}^{N}
\ln\frac{
  p(x_t \, | \, \mathbf{x}_{&lt;t}, \mathbf{y}_{&lt;t})
  }{
    p(x_t \, | \, \mathbf{x}_{&lt;t})
  }\]</div><p>The average here is taken over the <span>$N$</span> time bins of the target series. <span>$\mathbf{T}_{Y \to X}$</span> is the transfer entropy. In order to ensure that we have a quantity that converges in the limit of small bin size, we usually normalise the TE by the bin size <span>$\Delta t$</span>, to arrive at the transfer entropy rate <span>$\mathbf{\dot{T}}_{Y \to X} = \frac{1}{\Delta t}\mathbf{T}_{Y \to X}$</span>. This rate is the normalised <a href="https://en.wikipedia.org/wiki/Conditional_mutual_information">conditional mutual information</a> between the  current time bin of the target and the history of the source, conditioned on the history of the target. That is:</p><div>\[\mathbf{\dot{T}}_{Y\rightarrow X}
	=
	\frac{1}{\Delta t}
	I\left(
		X_t \, ; \, \mathbf{Y}_{&lt;t}
		\, \middle| \,
		\mathbf{X}_{&lt;t}
	\right)\]</div><p>Due to the fact that the mutual information is non-negative, the transfer entropy rate is similarly non-negative, despite the fact that the individual <span>$\mathbf{t}_{Y \to X}$</span> terms that make up the average can be negative.</p><p>The estimation of <span>$\mathbf{\dot{T}}_{Y \to X}$</span> on event-based data has traditionally been done in a very straightforward fashion. After performing time discretisation, for each time bin <span>$t$</span>, we estimate the probability of the value in that bin given its history embedding, <span>$p(x_t \, | \, \mathbf{x}_{t-m:t-1})$</span> using a plug-in or histogram estimator. Specifically, we find every occurrence of the embedding <span>$\mathbf{x}_{t-m:t-1}$</span> and record the values in the subsequent bin. The estimated probability is then the number of times we observed the same value as <span>$x_t$</span> divided by the total number of values recorded. Going back to our example, for the specific bin pulled out, we would find all instances of the pattern <span>$\{0, 1, 0, 0\}$</span> in the discretised time series. We would then count how many of these instances were followed by a <span>$0$</span>. The estimated conditional probability is then the ratio of the number of instances follwed by a <span>$0$</span> to the total number of instances. <span>$p(x_t \, | \, \mathbf{x}_{t-m:t-1}, \mathbf{y}_{t-l:t-1})$</span> is estimated in a similar fashion, except we are now looking for instances where both <span>$\mathbf{x}_{t-m:t-1}$</span> and <span>$\mathbf{y}_{t-l:t-1}$</span> match. We take the log of the ratio of these estimated probabilities to provide an estimate for <span>$\mathbf{t}_{Y \to X}$</span>. We then repeat this procedure for every time bin, find the average, normalise by <span>$\Delta t$</span> and, wham, we have estimated the TE!! (There are more computationally efficient ways of arriving at the same quantity)</p><p>Unfortunately, there are large limitations to estimating the TE in this fashion. Perhaps the most important of these is that when we perform time-discretisation, we are applying a lossy transformation to the data. So long as our bin size is larger than the time precision of the device used to record our data (as is usually the case), once the discretisation has been performed we cannot reconstruct the original time series in full detail - we have lost information. There could be history dependencies in the original data which occurr over a time scale smaller than the bin size. The discrete-time estimator will be blind to these relationships. The implication of this is that the discrete-time estimator is not guaranteed to converge to the true value of the TE in the limit of infinite data (it is not consistent).</p><p>Another large limitation relates to our choice of bin size <span>$\Delta t$</span>. The number of different history permutations grows exponentially in the number of bins that we use. On most computers this will limit us to a total budget of 20 to 25 bins accross all history embeddings before we run out of memory. Further, this exponential increase in the number of history permutations means that if we use too many bins in each embedding, then we risk undersampling the individual permutations. If a given history permutation only occurrs once or twice we cannot get an accurate estimate of the probability of the subsequent bin having a spike. The resulting limited budget on the bin-length of our history embeddings means that our choice of bin size will lead to a hard tradeoff. If we want to capture the influence of events occurring far in the past we can use large bins. On the other hand, if we want to capture relationships that occurr with fine time precision we can use smaller bins. However, we cannot capture both simultaneously.</p><p>The discrete-time estimator also provides estimates that are systematically far from the true value when it is provided with smaller datasets (it has high bias). This problem is compounded by the fact that its convergence to the true value is slow (see <a href="https://doi.org/10.1101/2020.06.16.154377">our paper</a> for examples).</p><p>CoTETE.jl presents an implementation of an estimator that is able to bypass these issues. It operates in continuous time on the raw timestamps of the events. This allows it to be consistent –- it is guaranteed to converge to the true value of the TE rate in the limit of large dataset size. The fact that it uses inter-event intervals for its history embeddings allows it to capture dependencies over relatively long ranges without any loss of precision. It also exhibits bias and convergence properties that are far superior to the discrete time approach (see <a href="https://doi.org/10.1101/2020.06.16.154377">our paper</a> for examples).</p><p>The below figure gives a diagram of how the history embeddings are represented in our approach.</p><p><img src="../intro_continuous.png" alt="Continuous TE"/></p><p>The estimator makes use of a <a href="https://doi.org/10.1103/PhysRevE.95.032319">recent result</a> which showed that, for stationary event-based data, the TE rate can be expressed as:</p><div>\[\mathbf{\dot{T}}_{Y\rightarrow X}
=
\lim_{\tau \to \infty}
\frac{1}{\tau}
\sum_{i=1}^{N_X}
\ln
\frac{
	\lambda_{
		x|\mathbf{{x}}_{&lt;t},\mathbf{{y}}_{&lt;t}
	}
	\left[
	\mathbf{{x}}_{&lt;x_i},\mathbf{{y}}_{&lt;x_i}
	\right]
	}{
		\lambda_{
			x|\mathbf{{x}}_{&lt;t}
		}
		\left[
		\mathbf{{x}}_{&lt;x_i}
		\right]
	}\]</div><p>To avoid confusion, it is worth emphasizing that the structure of the underlying data we are analysing has changed here. In the discrete-time case, <span>$X$</span> and <span>$Y$</span> were series of values at the sampled time points <span>$t_i$</span>. <span>$x_t \in X$</span> was then a binary value representing the presence or absence of a spike in the <span>$t$</span>-th bin. Here, however, <span>$X$</span> and <span>$Y$</span> are sets of the raw timestamps of the events. <span>$x_i \in X$</span> is then the time at which a spike in the target occurred. To avoid confusion around the history embeddings, we denote by <span>$\mathbf{{y}}_{&lt;x_i}$</span> some representation of the history of <span>$Y$</span> observed at the time point <span>$x_i$</span>. <span>$\lambda_{ 		x|\mathbf{{x}}_{&lt;t},\mathbf{{y}}_{&lt;t} 	} 	\left[ 		\mathbf{{x}}_{&lt;x_i},\mathbf{{y}}_{&lt;x_i} 	\right]$</span> is the instantaneous firing rate (rate of the occurrence of events per unit time) of the target conditioned on the histories of the target <span>$\mathbf{{x}}_{&lt;x_i}$</span> and source <span>$\mathbf{{y}}_{&lt;x_i}$</span> at the time points <span>$x_i$</span> of the events in the target process. <span>$\lambda_{ 		x|\mathbf{{x}}_{&lt;t} 	} 	\left[ 		\mathbf{{x}}_{&lt;x_i} 	\right]$</span> is the instantaneous firing rate of the of the target conditioned on its history alone, ignoring the history of the source. Note that <span>$\lambda_{x|\mathbf{{x}}_{&lt;t},\mathbf{{y}}_{&lt;t}}$</span> and <span>$\lambda_{x|\mathbf{{x}}_{&lt;t}}$</span> are defined at all points in time and not only at target events. <span>$\tau$</span> is the lenght of the target process.</p><p>An important property of this expression is that the sum is taken over the <span>$N_X$</span> events in the target process. No contributions need to be estimated for the &#39;white space&#39; in-between events. It <a href="https://doi.org/10.1103/PhysRevE.95.032319">was shown</a> that the discrete-time expression of the TE rate converges to this expression in the limit of small bin size. Fortunately, the contributions between events cancel and we are left with an expression which can be used for efficient estimation of the TE rate.</p><p>The dominant method for the estimation of information-theoretic quantities from continuous-valued data is the class of <span>$k$</span>-Nearest-Neighbours (<span>$k$</span>NN) estimators. There are multiple consistency proofs for the various estimators in this class, so we have guarantees that we will converge to the correct answer in the limit of infinite data.</p><p>Gaining an understanding of how these <span>$k$</span>NN estimators operate is most easily done in the simplest case of estimating the differential entropy of a random variable. Say we have the variable <span>$\mathbf{Z}$</span>, the differential entropy is then <span>$H(\mathbf{Z}) = \mathbb{E}_{P(\mathbf{Z})}[-\ln p(\mathbf{z})]$</span>. Here, <span>$\mathbb{E}_{P(\mathbf{Z})}$</span> represents that we are taking the expected value or average. We are attempting to estimate the entropy from a set of <span>$N_Z$</span> samples drawn from the distribution <span>$P(\mathbf{Z})$</span>. The below diagram shows an example of such a set of samples in an instance where <span>$\mathbf{z}$</span> is two dimensional (<span>$\mathbf{z} = \{z_1, z_2\}$</span>). Each sample in the set is represented by a point in the below diagram.</p><p><img src="../knn.png" alt="knn"/></p><p>In real applications, the underlying distribution <span>$P(\mathbf{Z})$</span> is unkown (if it were known we probably wouldn&#39;t need the estimator), but we have observed the set of samples from it in some experiment or data collection. Our strategy for estimating the entropy is to go through each of the sample points <span>$\mathbf{z}_i$</span> and find an estimate of the probability density at this point, <span>$\hat{p}(\mathbf{z}_i)$</span>. We can then take the negative log of these estimates and average them to come up with an estimator for the entropy:</p><div>\[\hat{H}(\mathbf{Z}) = -\frac{1}{N_Z}\sum_{i=1}^{N_Z} \ln \hat{p}(\mathbf{z}_i)\]</div><p>We now just need to find a way to construct the estimator for the probability density <span>$\hat{p}(\mathbf{z}_i)$</span> and this is where the <span>$k$</span>-Nearest-Neighbours searches are used. For a given point <span>$\mathbf{z}_i$</span>, we search for the <span>$k$</span>-th closest point to <span>$\mathbf{z}_i$</span> according to a distance metric of our choice. We record the distance <span>$\epsilon$</span> to this point. The probability density can then be estimated as the ratio of the probability mass <span>$k/(N_Z - 1)$</span> to the volume of the <span>$\epsilon$</span>-ball formed around the point. This process is demonstrated in the above figure, for a two-dimensional variable with <span>$k = 3$</span> and the euclidean distance. For <span>$p$</span>-norms we can express this volume as <span>$c_{d, L^p}\epsilon^d$</span> where <span>$c_{d, L^p}$</span> is the volume of the <span>$d$</span>-dimensional unit ball under the norm <span>$L^p$</span>. The exact expression for <span>$c_{d, L^p}$</span> is not very important as it will end up cancelling out later. We will usually use the <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan</a>, <a href="https://en.wikipedia.org/wiki/Uniform_norm">maximum</a> or <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean</a> norm.</p><p>This gives us:</p><div>\[\hat{p}(\mathbf{z}_i)
=
\frac{
	k
	}{
		\left(N_{Z} - 1\right)
		c_{d, L}
		\epsilon_i^d
	}\]</div><p>Integrating this into our strategy for estimating entropy we have the estimator:</p><div>\[\hat{H}(Z) =
-\frac{1}{N_Z} \sum_{i=1}^{N_Z}
\ln
\frac{
	k
	}{
		\left(N_{Z} - 1\right)
		c_{d, L}
		\epsilon_i^d
	}\]</div><p>We then add the bias-correction term <span>$\ln k - \psi(k)$</span>. <span>$\psi(x)$</span> is the digamma function. This gives us <span>$\hat{H}_{\text{KL}}$</span>, the Kozachenko-Leonenko <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup> estimator of differential entropy:</p><div>\[		\hat{H}_{\text{KL}}(Z) = -\psi(k) + \ln(N_Z - 1) + \ln c_{d, L}  
		+ \frac{d}{N_Z} \sum_{i=1}^{N_Z}
		\ln \epsilon_i\]</div><p>It is most unfortunate that Kozachenko-Leonenko and Kullback-Leibler share the same abbreviation of their surnames. This has caught me on a few occassions.</p><p>Before we can move on, however, we need one more arrow in our quiver: a <span>$k$</span>NN estimator of cross entropy. The differential cross entropy can be written as <span>$H_A(\mathbf{Z}) = \mathbb{E}_{P(\mathbf{Z})}[-\ln p_A(\mathbf{z})]$</span>. Here the probability density to which we apply the logarithm is different to the distribution over which we take the expectation. This actually starts to make a bit more intuitive sense when we start to think about how we would estimate the this quantity using a  <span>$k$</span>-NN estimator. We have our set of sample points drawn from the distribution <span>$P(\mathbf{Z})$</span>. We then draw another set of sample points from the distribution <span>$P_A(\mathbf{Z})$</span>. We go through each point in the first set (because the expectation is over <span>$P(\mathbf{Z})$</span>), and at each point find the <span>$k$</span> nearest neighbours <em>in the second set</em> (because we want the density <span>$p_A(\mathbf{z})$</span>). We can then use the same expression that we did for the KL estimator of the entropy. The below diagram illustrates this process</p><p><img src="../knn_cross.png" alt="knn_cross"/></p><p><span>$k$</span>-NN estimators of other information-theoretic quantities operate by decomposing the quantity into a sum of entropy and cross entropy terms. Each of these terms can then be estimated using <span>$\hat{H}_{\text{KL}}$</span>. Sometimes, as in the case of the famous <a href="https://doi.org/10.1103/PhysRevE.69.066138">KSG estimator</a> of mutual information, a scheme is divised whereby the same radius is used for a given point across multiple entropy terms. This <a href="https://doi.org/10.1109/TIT.2018.2807481">has been found</a> to reduce the bias.</p><p>Unfortunately, if we try to apply this strategy to our expression for the TE rate we will hit a snag. This is because this expression is written in terms of logs of <em>rates</em>, as opposed to logs of probability densities. This means that we have no entropy terms!!</p><p>The situation can be remedied by re-writing our expression for the TE in continuous time as follows:</p><div>\[\mathbf{\dot{T}}_{Y \rightarrow X} =
	\bar{\lambda}_X
		\mathbb{E}_{P_X}
		\bigg[
				\ln
		\frac{
			p_X \left(
				\mathbf{{x}}_{&lt;x}, \mathbf{{y}}_{&lt;x}
			\right)
		}{
			p_X \left(
				\mathbf{{x}}_{&lt;x}
			\right)
		}
		+ \ln
		\frac{
			p_U \left(
				\mathbf{{x}}_{&lt;x}
			\right)
		}{
			p_U \left(
				\mathbf{{x}}_{&lt;x}, \mathbf{{y}}_{&lt;x}
			\right)
		}
		\bigg]\]</div><p>See <a href="https://doi.org/10.1101/2020.06.16.154377">our paper</a> for a derivation. As this expression has probability densities, as opposed to rates, it will yield entropy and cross entropy terms. The densities <span>$p_X$</span> refer to the probability density of histories observed at events in the target process and the densities <span>$p_U$</span> refer to the probability densities of histories observed anywhere in the time series, not conditioned on events in the target process. <span>$\bar{\lambda}_X$</span> is the average rate of events in the target process.</p><p>This expression has shifted our view on the probabilities that we are trying to estimate. In the original continuous-time expression for the TE rate, we were asking, given a certain history, what the probability of an event is in the next small time window. In this new expression we are asking, given a certain history observed at an event, what is the probability density of observing that history at an event. We contrast this with the probability of observing that history anywhere in the process.   </p><p>Writing our new expression as a sum of entropy and cross entropy terms we have:</p><div>\[		\dot{\mathbf{T}}_{Y \rightarrow X} =
		\bar{\lambda}_X
		\bigg[
		- H\left(
			\mathbf{{X}}_{&lt;X}, \mathbf{{Y}}_{&lt;X}
		\right)
		+ H\left(
			\mathbf{{X}}_{&lt;X}
		\right)
		+ H_{P_U}\left(
			\mathbf{{X}}_{&lt;X}, \mathbf{{Y}}_{&lt;X}
		\right)
       - H_{P_U}\left(
			\mathbf{{X}}_{&lt;X}
		\right)
		\bigg]\]</div><p>The only outstanding issue that needs addressing is how we draw samples according to <span>$P_X$</span> and <span>$P_U$</span>. As <span>$P_X$</span> is just the distribution of histories observed at events in the target process, we just construct history embeddings at each target event and this is our set of samples. For <span>$P_U$</span> we construct history embeddings at random points in the process.</p><p>We now just apply the KL estimators of differential entropy and cross entropy and we have an estimate of the TE rate!!</p><p>CoTETE.jl actually operates in a slightly more complicated fashion, utilising a scheme to share radii across entropy terms for a given point. See <a href="https://doi.org/10.1101/2020.06.16.154377">our paper</a> section IV A 5 for the details of this scheme.</p><h2 id="References-1"><a class="docs-heading-anchor" href="#References-1">References</a><a class="docs-heading-anchor-permalink" href="#References-1" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Schreiber, T. (2000). Measuring information transfer. Physical review letters, 85(2), 461.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Bossomaier, T., Barnett, L., Harré, M., &amp; Lizier, J. T. (2016). An introduction to transfer entropy. Cham: Springer International Publishing 65-95.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>Lizier, J. T. (2012). The local information dynamics of distributed computation in complex systems. Springer Science &amp; Business Media.</li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a>Kozachenko, L. F., &amp; Leonenko, N. N. (1987). Sample estimate of the entropy of a random vector. Problemy Peredachi Informatsii, 23(2), 9-16.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../quickStart/">Quick Start »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 26 June 2020 11:44">Friday 26 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
